USE [ENGAGENBSF]
GO
/****** Object:  StoredProcedure [ENGAGENBSF].[PA_SYS_WRITE_ATTACHMENT_TEMP]    Script Date: 01/24/2019 12:17:20 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
ALTER PROCEDURE [ENGAGENBSF].[PA_SYS_WRITE_ATTACHMENT_TEMP] (@PS_PAR_KEY VARCHAR(100), @PS_DESCRIP VARCHAR(250), @PS_FILE_NAME VARCHAR(255), @PS_USER_ID VARCHAR(30), @PO_ATTACHMENT VARBINARY(MAX) = NULL, @PS_QUERY VARCHAR(8000) = NULL, @PS_ROW_HEADER VARCHAR(4000) = NULL, @PS_FILE_FORMAT VARCHAR(3) = NULL, @PS_RET_MESSAGE VARCHAR(440) = NULL OUTPUT) AS

-- =========================================================================================================================
-- AUTOR: TITO - ENGAGE SOFTWARE COMPANY
-- FECHA DE CREACIÓN: 07/04/2014
-- EDITOR: TITO - ENGAGE SOFTWARE COMPANY
-- FECHA DE MODIFICACIÓN: 09/05/2014
-- TABLAS LEÍDAS: PHYSICAL_ATTACHED_DOCUMENT, PHYSICAL_JOB
-- TABLAS MODIFICADAS: PHYSICAL_ATTACHED_DOCUMENT
-- DESCRIPCIÓN: PROCEDIMIENTO QUE ADJUNTA A UN TRÁMITE DATOS BINARIOS PASADOS POR PARÁMETRO O LOS RESULTADO DE UNA CONSULTA INFORMADA.
-- CONSIDERACIONES:
-- LOS VALORES NULOS SE TRANSFORMAN A CADENAS DE LONGITUD CERO, EXCEPTO PARA LAS FECHAS, QUE TOMAN EL VALOR '19000101'.
-- 1. EL PARÁMETRO @PS_PAR_KEY ES LA CLAVE DEL TRÁMITE AL QUE SE VA A ADJUNTAR EL ARCHIVO.
-- 2. EL PARÁMETRO @PS_DESCRIP ES LA DESCRIPCIÓN DEL ADJUNTO.
-- 3. EL PARÁMETRO @PS_FILE_NAME ES EL NOMBRE DEL ARCHIVO QUE SE ADJUNTA.
-- 4. EL PARÁMETRO @PS_USER_ID ES EL USUARIO QUE REALIZA LA OPERACIÓN.
-- 5. EL PARÁMETRO @PO_ATTACHMENT ES EL CONJUNTO DE DATOS BINARIOS INFORMADOS QUE SE GRABARÁ. ES EXCLUYENTE CON @PS_QUERY.
-- 6. EL PARÁMETRO @PS_QUERY ES LA CONSULTA CUYOS RESULTADOS SERÁN GRABADOS EN LA TABLA. ES EXCLUYENTE CON @PO_ATTACHMENT.
-- 7. EL PARÁMETRO @PS_ROW_HEADER ES LA FILA CON LOS NOMBRES DE COLUMNAS DE ENCABEZADO DE LOS RESULTADOS DE LA CONSULTA INFORMADA.
-- 7.1. DEBEN VENIR SEPARADOS POR COMA Y SIN ESPACIOS ENTRE MEDIO, AL INICIO O AL FINAL.
-- 8. EL PARÁMETRO @PS_FILE_FORMAT ES EL FORMATO DE ARCHIVO QUE SE USARÁ PARA GUARDAR LOS RESULTADOS DE LA CONSULTA INFORMADA.
-- 8.1. VALORES ADMITIDOS: 'TSV' (TABULATION-SEPARATED VALUES), 'CSV' (COMMA-SEPARATED VALUES), 'TXT' (SEMICOLON-SEPARATED VALUES) Y 'XML' (EXCEL 2003 XML FILE).
-- 9. EL PARÁMETRO DE SALIDA @PS_RET_MESSAGE DEVUELVE EL MENSAJE DE ERROR. NULL SI NO HUBO.
-- =========================================================================================================================
-- FECHA DE MODIFICACIÓN: 08/12/2016
-- AUTOR: PBARBOZA - ENGAGE SOFTWARE COMPANY
-- DESCRIPCIÓN: DEBIDO A SALIDAS POR TIMEOUT POR EL VOLUMEN DE DATOS EN LA TABLA PHYSICAL_ATTACHED_DOCUMENT SE CREA UNA TABLA TEMPORAL PHYSICAL_ATTACHED_DOCUMENT_TMP
--				QUE SE PROCESARA COMO LO HACIA EL SP ANTERIORMENTE Y LUEGO CULMINA CON LA INSERCION DEL REGISTRO A LA PHYSICAL_ATTACHED_DOCUMENT.
-- =========================================================================================================================


SET NOCOUNT ON;
SET XACT_ABORT ON;
SET DATEFORMAT YMD;

-- DECLARACIÓN E INICIALIZACIÓN DE VARIABLES DE ERROR Y AUXILIARES.
DECLARE @LNERRORNUM AS INTEGER,
	@LNSEVERITY AS SMALLINT,
	@LNFILAS_AFEC AS INTEGER,
	@LDINICIO_OPE AS DATETIME,
	@LNDURACION AS INTEGER,
	@LSOPERA AS VARCHAR(30),
	@LSPROC AS VARCHAR(30),
	@LSTABLA AS VARCHAR(30),
	@LSERRORLOG AS VARCHAR(440),
	@LSERRORDESC AS VARCHAR(440),
	@LSSQL_CMD AS VARCHAR(4000)
;
SELECT 	
	@LNERRORNUM		= 0,
	@LNSEVERITY		= 16,
	@LNFILAS_AFEC	= 0,
	@LDINICIO_OPE	= GETDATE(),
	@LNDURACION		= 0,
	@LSOPERA		= 'EXECUTE',
	@LSPROC			= OBJECT_NAME(@@PROCID),
	@LSTABLA		= 'NINGUNA',
	@LSERRORLOG		= @@SERVERNAME + '.' + DB_NAME() + '.' + USER_NAME() + '.' + OBJECT_NAME(@@PROCID) + ' - ',
	@LSERRORDESC	= NULL,
	@LSSQL_CMD		= NULL
;

-- DECLARA LAS VARIABLES.
DECLARE
@LS_PAR_KEY VARCHAR(100),
@LS_DESCRIP VARCHAR(250),
@LS_FILE_NAME VARCHAR(255),
@LS_USER_ID VARCHAR(30),
@LO_ATTACHMENT VARBINARY(MAX),
@LS_QUERY VARCHAR(8000),
@LS_ROW_HEADER VARCHAR(MAX),
@LS_FILE_FORMAT VARCHAR(3),
@LS_RET_MESSAGE VARCHAR(440),
@LS_CELL_SEPARATOR VARCHAR(1),
@LS_ROW_END VARCHAR(2),
@LS_FILE_HEADER VARCHAR(MAX),
@LS_FILE_FOOTER VARCHAR(MAX),
@LS_CELL_PREFIX VARCHAR(100),
@LS_CELL_SUFFIX VARCHAR(100),
@LS_ROW_PREFIX VARCHAR(100),
@LS_ROW_SUFFIX VARCHAR(100),
@LS_IMAGE_LEN VARCHAR(10),
@LS_PKEY VARCHAR(36),
@LN_DATA_LENGTH BIGINT,
@LN_@OFFSET BIGINT,
@LS_SQL_CUR VARCHAR(MAX),
@LN_COL_COUNT INTEGER,
@LN_COUNT INTEGER,
@LS_FIRST_DATE VARCHAR(8),
@LS_FIRST_ASCII_CHAR VARCHAR(1);

-- ASIGNA VALORES PREDETERMINADOS A LAS VARIABLES.
SELECT	
	@LS_PAR_KEY		= NULLIF(LTRIM(RTRIM(@PS_PAR_KEY)), ''),
	@LS_USER_ID		= NULLIF(LTRIM(RTRIM(@PS_USER_ID)), ''),
	@LS_FILE_NAME	= REPLACE(REPLACE(REPLACE(CONVERT(VARCHAR, @LDINICIO_OPE, 120), ' ', '_'), '-', ''), ':', '') + '_' + @LS_USER_ID + '.' + NULLIF(LTRIM(RTRIM(@PS_FILE_NAME)), ''),
	@LO_ATTACHMENT	= CONVERT(VARBINARY(MAX), NULLIF(LTRIM(RTRIM(@PO_ATTACHMENT)), '')),
	@LS_QUERY		= NULLIF(LTRIM(RTRIM(@PS_QUERY)), ''),
	@LS_FILE_FORMAT = ISNULL(NULLIF(LTRIM(RTRIM(UPPER(@PS_FILE_FORMAT))), ''), 'TXT'),
	@LS_DESCRIP		= NULLIF(LTRIM(RTRIM(@PS_DESCRIP)), '') + ' (ETL ' + @LS_FILE_FORMAT + ' FILE READ ON ' + CONVERT(VARCHAR, @LDINICIO_OPE, 120) + ')',
	@LS_ROW_HEADER	= NULLIF(RTRIM(LTRIM(UPPER(REPLACE(@PS_ROW_HEADER, SPACE(1), '')))), ''),
	@LS_RET_MESSAGE = NULL,
	@LS_CELL_SEPARATOR = CASE @LS_FILE_FORMAT WHEN 'XLS' THEN CHAR(9) WHEN 'CSV' THEN ',' ELSE ';' END,
	@LS_ROW_END		= CHAR(13) + CHAR(10),
	@LS_FILE_HEADER = CASE @LS_FILE_FORMAT WHEN 'XML' THEN '<?xml version="1.0"?>' + @LS_ROW_END + '<?mso-application progid="Excel.Sheet"?>' + @LS_ROW_END + '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" xmlns:html="http://www.w3.org/TR/REC-html40">' + @LS_ROW_END + SPACE(1) + '<Worksheet ss:Name="EXCEL_XML_IMPORT">' + @LS_ROW_END + SPACE(2) + '<Table>' + @LS_ROW_END ELSE '' END,
	@LS_FILE_FOOTER = CASE @LS_FILE_FORMAT WHEN 'XML' THEN SPACE(2) + '</Table>' + @LS_ROW_END + SPACE(1) + '</Worksheet>' + @LS_ROW_END + '</Workbook>' + @LS_ROW_END ELSE '' END,
	@LS_CELL_PREFIX = '<Cell><Data ss:Type="String">',
	@LS_CELL_SUFFIX = '</Data></Cell>',
	@LS_ROW_PREFIX	= SPACE(3) + '<Row>',
	@LS_ROW_SUFFIX	= '</Row>',
	@LS_IMAGE_LEN	= RIGHT(REPLICATE('0', 10) + CONVERT(VARCHAR(10), ISNULL(DATALENGTH(@LO_ATTACHMENT), 0)), 10),
	@LS_PKEY		= NEWID(),
	@LN_DATA_LENGTH = 0,
	@LN_@OFFSET		= 0,
	@LS_SQL_CUR		= NULL,
	@LN_COL_COUNT	= 0,
	@LN_COUNT		= 0,
	@LS_FIRST_DATE	= '19000101',
	@LS_FIRST_ASCII_CHAR = ''; -- USAREMOS UNA CADENA DE LONGITUD CERO.

-- DECLARO LA TRANSACCIÓN.
BEGIN TRANSACTION

-- EVALÚA QUE SE HAYAN ENVIADO LOS PARÁMETROS OBLIGATORIOS.
IF (@LS_PAR_KEY IS NOT NULL AND @LS_DESCRIP IS NOT NULL AND @LS_FILE_NAME IS NOT NULL AND @LS_USER_ID IS NOT NULL) BEGIN
	-- VERIFICA QUE EXISTA EL PROCESO AL QUE SE LE VA A ADJUNTAR EL ARCHIVO.
	SELECT @LN_COUNT = COUNT(1) FROM PHYSICAL_JOB WHERE (PKEY = @LS_PAR_KEY);
	IF (@LN_COUNT > 0) BEGIN
		-- VERIFICA QUE NO EXISTA EL ARCHIVO QUE SE VA A GRABAR.
		SELECT @LN_COUNT = COUNT(1) FROM PHYSICAL_ATTACHED_DOCUMENT WHERE (PAR_KEY = @LS_PAR_KEY AND FILE_NAME = @LS_FILE_NAME);
		IF (@LN_COUNT = 0) BEGIN
			-- HACE QUE LA EXTENSIÓN DEL ARCHIVO COINCIDA CON EL FORMATO INFORMADO.
			IF NOT (RIGHT(UPPER(@LS_FILE_NAME), 4) = '.' + @LS_FILE_FORMAT) BEGIN
				SET @LS_FILE_NAME = @LS_FILE_NAME + '.' + @LS_FILE_FORMAT;
			END;
			
			TRUNCATE TABLE PHYSICAL_ATTACHED_DOCUMENT_TMP

			-- INSERTA EL REGISTRO CON O SIN EL ADJUNTO PASADO POR PARÁMETRO EN LA TABLA PHYSICAL_ATTACHED_DOCUMENT.
			INSERT INTO	PHYSICAL_ATTACHED_DOCUMENT_TMP (PKEY, PAR_KEY, ATTACHED_DOC, ATTACHED_MESSAGE, FILE_NAME, TS_BEGIN, TS_END, TS_USER_ID, IMAGE_LEN, TS_CREATED_USER_ID)
			VALUES		(@LS_PKEY, @LS_PAR_KEY, ISNULL(@LO_ATTACHMENT, 0X), @LS_DESCRIP, @LS_FILE_NAME, @LDINICIO_OPE, @LDINICIO_OPE, @LS_USER_ID, @LS_IMAGE_LEN, @LS_USER_ID);
			SELECT @LSOPERA = 'INSERT', @LSTABLA = 'PHYSICAL_ATTACHED_DOCUMENT_TMP', @LNFILAS_AFEC = @@ROWCOUNT, @LNERRORNUM = @@ERROR;
			IF (@LNERRORNUM <> 0) GOTO FALLO;

			-- SI NO HAN ENVIADO EL ADJUNTO POR PARÁMETRO, ENTONCES HAY QUE VERIFICAR LA CONSULTA INFORMADA.
			IF (@LO_ATTACHMENT IS NULL) BEGIN
				-- SI LA CONSULTA INFORMADA NO ES NULA, SE PUEDE OPERAR.
				IF (@LS_QUERY IS NOT NULL) BEGIN
					-- SI EL REGISTRO DE CABECERA NO ES NULO, SE PUEDE OPERAR.
					IF (@LS_ROW_HEADER IS NOT NULL) BEGIN
						-- DETERMINA CUÁNTAS COLUMNAS SE INFORMARON EN EL REGISTRO DE CABECERA, PARA SABER CUÁNTAS VARIABLES TENDRÁ QUE POBLAR EL CURSOR DE LA CONSULTA INFORMADA.
						SET @LN_COL_COUNT = LEN(@LS_ROW_HEADER) - LEN(REPLACE(@LS_ROW_HEADER, ',', '')) + 1;

						IF (@LS_FILE_FORMAT = 'XML') BEGIN
							-- ASIGNA LOS PREFIJOS QUE NO SE REPITEN DEL REGISTRO DE CABECERA.
							SET @LS_FILE_HEADER = @LS_FILE_HEADER + @LS_ROW_PREFIX;
							-- ITERA HASTA QUE NO QUEDAN MÁS NOMBRES DENTRO DEL REGISTRO DE CABECERA.
							WHILE (@LS_ROW_HEADER <> '') BEGIN
								-- BUSCA LA POSICIÓN DE LA PRIMERA COMA DEL REGISTRO DE CABECERA.
								SET @LN_@OFFSET = CHARINDEX(',', @LS_ROW_HEADER, 1);
								-- SI NO ENCUENTRA UNA COMA, ENTONCES SE TRATA DE LA ÚLTIMA COLUMNA DEL REGISTRO DE CABECERA.
								IF (@LN_@OFFSET = 0) BEGIN
									-- CONCATENA EN EL REGISTRO DE CABECERA PREFIJO, COLUMNA Y SUFIJO DE LA ÚLTIMA CELDA.
									SET @LS_FILE_HEADER = @LS_FILE_HEADER + @LS_CELL_PREFIX + @LS_ROW_HEADER + @LS_CELL_SUFFIX;
									-- ANULA LA CADENA DEL REGISTRO DE CABECERA PARA CORTAR EL CICLO.
									SET @LS_ROW_HEADER = '';
								END
								ELSE BEGIN
									-- CONCATENA EN EL REGISTRO DE CABECERA PREFIJO, COLUMNA Y SUFIJO DE CADA CELDA.
									SET @LS_FILE_HEADER = @LS_FILE_HEADER + @LS_CELL_PREFIX + SUBSTRING(@LS_ROW_HEADER, 1, @LN_@OFFSET - 1) + @LS_CELL_SUFFIX;
									-- DESCARTA LA COLUMNA YA USADA DE LA CADENA DEL REGISTRO DE CABECERA.
									SET @LS_ROW_HEADER = SUBSTRING(@LS_ROW_HEADER, @LN_@OFFSET + 1, LEN(@LS_ROW_HEADER));
								END;
							END;
							-- ASIGNA LOS SUFIJOS QUE NO SE REPITEN DEL REGISTRO DE CABECERA.
							SET @LS_FILE_HEADER = @LS_FILE_HEADER + @LS_ROW_SUFFIX + @LS_ROW_END;
						END
						ELSE BEGIN
							-- PREPARA EL REGISTRO DE CABECERA DE AQUELLOS ARCHIVOS CON FORMATO DISTINTO A XML.
							SET @LS_FILE_HEADER = REPLACE(@LS_ROW_HEADER, ',', @LS_CELL_SEPARATOR) + @LS_ROW_END;
						END;

						-- ASIGNA EL REGISTRO DE CABECERA A LA VARIABLE DE TIPO BLOB.
						SET @LO_ATTACHMENT = CONVERT(VARBINARY(MAX), @LS_FILE_HEADER);
						-- INICIALIZA LAS VARIABLES QUE REQUIERE LA FUNCIÓN WRITE DE LA COLUMNA BLOB. CANTIDAD DE BYTES DEL BLOB Y VALOR INICIAL DE OFFSET.
						SET @LN_DATA_LENGTH = DATALENGTH(@LO_ATTACHMENT);
						SET @LN_@OFFSET = 0;

						-- ACTUALIZA PHYSICAL_ATTACHED_DOCUMENT.ATTACHED_DOC CON EL REGISTRO DE CABECERA.
						UPDATE TOP(1) PHYSICAL_ATTACHED_DOCUMENT_TMP
						SET	ATTACHED_DOC.WRITE(@LO_ATTACHMENT, @LN_@OFFSET, @LN_DATA_LENGTH)
						WHERE	(PKEY = @LS_PKEY);

						-- SUMA LA LONGITUD EN BYTES DEL SEGMENTO BLOB YA GRABADO AL VALOR DE OFFSET.
						SET @LN_@OFFSET = @LN_@OFFSET + @LN_DATA_LENGTH;

						-- DECLARA VARIABLES LOCALES PARA OPERAR DENTRO DEL SQL DINÁMICO.
						SET @LS_SQL_CUR = 'SET DATEFORMAT YMD;' + @LS_ROW_END + @LS_ROW_END;
						SET @LS_SQL_CUR = @LS_SQL_CUR + 'DECLARE' + @LS_ROW_END + '@LN_DATA_LENGTH2 BIGINT,' + @LS_ROW_END + '@LN_@OFFSET2 BIGINT,' + @LS_ROW_END + '@LO_ATTACHMENT2 VARBINARY(MAX);' + @LS_ROW_END + @LS_ROW_END;

						-- ELIMINA EL CURSOR LOCAL, SI EXISTE.
						SET @LS_SQL_CUR = @LS_SQL_CUR + 'IF (CURSOR_STATUS(''LOCAL'', ''LO_CUR1'') >= 0) BEGIN' + @LS_ROW_END;
						SET @LS_SQL_CUR = @LS_SQL_CUR + CHAR(9) + 'CLOSE LO_CUR1;' + @LS_ROW_END;
						SET @LS_SQL_CUR = @LS_SQL_CUR + CHAR(9) + 'DEALLOCATE LO_CUR1;' + @LS_ROW_END;
						SET @LS_SQL_CUR = @LS_SQL_CUR + 'END;' + @LS_ROW_END + @LS_ROW_END;

						-- ASIGNA VALORES A LAS VARIABLES LOCALES PARA OPERAR DENTRO DEL SQL DINÁMICO.
						SET @LS_SQL_CUR = @LS_SQL_CUR + 'SET @LN_@OFFSET2 = ' + CONVERT(VARCHAR, @LN_@OFFSET) + ';' + @LS_ROW_END + @LS_ROW_END;

						-- ASIGNACIÓN EN CONTADOR AUXILIAR.
						SET @LN_COUNT = 1;
						-- ITERACIÓN PARA ARMAR SQL DINÁMICO.
						WHILE (@LN_COUNT <= @LN_COL_COUNT) BEGIN
							-- DECLARA TANTAS VARIABLES LOCALES COMO COLUMNAS SE INFORMARON EN EL REGISTRO DE CABECERA.
							SET @LS_SQL_CUR = @LS_SQL_CUR + 'DECLARE @LS_COL' + CONVERT(VARCHAR, @LN_COUNT) + ' VARCHAR(4000)' + ';' + @LS_ROW_END;
							-- INCREMENTA EL CONTADOR DE COLUMNAS.
							SET @LN_COUNT = @LN_COUNT + 1;
						END;

						-- DECLARA UN CURSOR CON LA CONSULTA INFORMADA.
						SET @LS_SQL_CUR = @LS_SQL_CUR + @LS_ROW_END + 'DECLARE LO_CUR1 CURSOR LOCAL FAST_FORWARD TYPE_WARNING FOR ' + @LS_QUERY + @LS_ROW_END;

						-- ABRE EL CURSOR.
						SET @LS_SQL_CUR = @LS_SQL_CUR + @LS_ROW_END + 'OPEN LO_CUR1;' + @LS_ROW_END;

						-- PROCESA LA PRIMERA FILA.
						SET @LS_SQL_CUR = @LS_SQL_CUR + 'FETCH NEXT FROM LO_CUR1 INTO ';
						-- ASIGNACIÓN EN CONTADOR AUXILIAR.
						SET @LN_COUNT = 1;
						-- ITERACIÓN PARA ARMAR SQL DINÁMICO.
						WHILE (@LN_COUNT <= @LN_COL_COUNT) BEGIN
							-- ADICIONA VARIABLES AL FETCH DEL CURSOR.
							IF (@LN_COUNT < @LN_COL_COUNT) BEGIN
								SET @LS_SQL_CUR = @LS_SQL_CUR + '@LS_COL' + CONVERT(VARCHAR, @LN_COUNT) + ', ';
							END
							ELSE BEGIN
								SET @LS_SQL_CUR = @LS_SQL_CUR + '@LS_COL' + CONVERT(VARCHAR, @LN_COUNT) + ';' + @LS_ROW_END;
							END;
							-- INCREMENTA EL CONTADOR DE COLUMNAS.
							SET @LN_COUNT = @LN_COUNT + 1;
						END;

						-- CICLO WHILE.
						SET @LS_SQL_CUR = @LS_SQL_CUR + @LS_ROW_END + 'WHILE (@@FETCH_STATUS = 0) BEGIN' + @LS_ROW_END;

						-- ASIGNACIÓN EN CONTADOR AUXILIAR.
						SET @LN_COUNT = 1;
						-- ITERACIÓN PARA ARMAR SQL DINÁMICO.
						WHILE (@LN_COUNT <= @LN_COL_COUNT) BEGIN
							-- EVALUACIÓN DE CADA VARIABLE DEL CURSOR PARA AJUSTAR EL FORMATO, SI FUERA FECHA.
							SET @LS_SQL_CUR = @LS_SQL_CUR + CHAR(9) + 'IF (ISDATE(@LS_COL' + CONVERT(VARCHAR, @LN_COUNT) + ') = 1 AND LEN(@LS_COL' + CONVERT(VARCHAR, @LN_COUNT) + ') > 7) BEGIN' + @LS_ROW_END;
							SET @LS_SQL_CUR = @LS_SQL_CUR + CHAR(9) + CHAR(9) + 'SET @LS_COL' + CONVERT(VARCHAR, @LN_COUNT) + ' = CONVERT(VARCHAR, CONVERT(DATETIME, ISNULL(@LS_COL' + CONVERT(VARCHAR, @LN_COUNT) + ', ' + CHAR(39) + @LS_FIRST_DATE + CHAR(39) + ')), 112);' + @LS_ROW_END;
							SET @LS_SQL_CUR = @LS_SQL_CUR + CHAR(9) + 'END' + @LS_ROW_END;
							SET @LS_SQL_CUR = @LS_SQL_CUR + CHAR(9) + 'ELSE BEGIN' + @LS_ROW_END;
							SET @LS_SQL_CUR = @LS_SQL_CUR + CHAR(9) + CHAR(9) + 'SET @LS_COL' + CONVERT(VARCHAR, @LN_COUNT) + ' = REPLACE(ISNULL(@LS_COL' + CONVERT(VARCHAR, @LN_COUNT) + ', ' + CHAR(39) + @LS_FIRST_ASCII_CHAR + CHAR(39) + '), CHAR(0), ' + CHAR(39) + @LS_FIRST_ASCII_CHAR + CHAR(39) + ');' + @LS_ROW_END;
							SET @LS_SQL_CUR = @LS_SQL_CUR + CHAR(9) + 'END;' + @LS_ROW_END + @LS_ROW_END;
							-- INCREMENTA EL CONTADOR DE COLUMNAS.
							SET @LN_COUNT = @LN_COUNT + 1;
						END;

						-- ASIGNA EL REGISTRO ACTUAL A LA VARIABLE DE TIPO BLOB.
						SET @LS_SQL_CUR = @LS_SQL_CUR + CHAR(9) + 'SET @LO_ATTACHMENT2 = CONVERT(VARBINARY(MAX), ';
						IF (@LS_FILE_FORMAT = 'XML') BEGIN
							-- ASIGNA LOS PREFIJOS QUE NO SE REPITEN DEL REGISTRO ACTUAL.
							SET @LS_SQL_CUR = @LS_SQL_CUR + CHAR(39) + @LS_ROW_PREFIX + CHAR(39) + ' + ';
						END;
						-- ASIGNACIÓN EN CONTADOR AUXILIAR.
						SET @LN_COUNT = 1;
						-- ITERACIÓN PARA ARMAR SQL DINÁMICO.
						WHILE (@LN_COUNT <= @LN_COL_COUNT) BEGIN
							IF (@LN_COUNT < @LN_COL_COUNT) BEGIN
								IF (@LS_FILE_FORMAT = 'XML') BEGIN
									-- CONCATENA EN EL REGISTRO ACTUAL PREFIJO, COLUMNA Y SUFIJO DE LA CELDA.
									SET @LS_SQL_CUR = @LS_SQL_CUR + CHAR(39) + @LS_CELL_PREFIX + CHAR(39) + ' + ' + '@LS_COL' + CONVERT(VARCHAR, @LN_COUNT) + ' + ' + CHAR(39) + @LS_CELL_SUFFIX + CHAR(39) + ' + ';
								END
								ELSE BEGIN
									SET @LS_SQL_CUR = @LS_SQL_CUR + '@LS_COL' + CONVERT(VARCHAR, @LN_COUNT) + ' + ' + 'CHAR(' + CONVERT(VARCHAR, ASCII(@LS_CELL_SEPARATOR)) + ')' + ' + ';
								END;
							END
							ELSE BEGIN
								IF (@LS_FILE_FORMAT = 'XML') BEGIN
									-- CONCATENA EN EL REGISTRO ACTUAL PREFIJO, COLUMNA Y SUFIJO DE LA ÚLTIMA CELDA.
									SET @LS_SQL_CUR = @LS_SQL_CUR + CHAR(39) + @LS_CELL_PREFIX + CHAR(39) + ' + ' + '@LS_COL' + CONVERT(VARCHAR, @LN_COUNT) + ' + ' + CHAR(39) + @LS_CELL_SUFFIX + CHAR(39) + ' + ' + CHAR(39) + @LS_ROW_SUFFIX + CHAR(39) + ' + CHAR(13) + CHAR(10));' + @LS_ROW_END;
								END
								ELSE BEGIN
									SET @LS_SQL_CUR = @LS_SQL_CUR + '@LS_COL' + CONVERT(VARCHAR, @LN_COUNT) + ' + CHAR(13) + CHAR(10));' + @LS_ROW_END;
								END;
							END;
							-- INCREMENTA EL CONTADOR DE COLUMNAS.
							SET @LN_COUNT = @LN_COUNT + 1;
						END;

						-- INICIALIZA LAS VARIABLES QUE REQUIERE LA FUNCIÓN WRITE DE LA COLUMNA BLOB. CANTIDAD DE BYTES DEL BLOB Y VALOR DE OFFSET.
						SET @LS_SQL_CUR = @LS_SQL_CUR + @LS_ROW_END + CHAR(9) + 'SET @LN_DATA_LENGTH2 = DATALENGTH(@LO_ATTACHMENT2);' +  @LS_ROW_END;

						-- ACTUALIZA PHYSICAL_ATTACHED_DOCUMENT.ATTACHED_DOC CON EL REGISTRO ACTUAL.
						SET @LS_SQL_CUR = @LS_SQL_CUR + @LS_ROW_END + CHAR(9) + 'UPDATE	TOP (1) PHYSICAL_ATTACHED_DOCUMENT_TMP';
						SET @LS_SQL_CUR = @LS_SQL_CUR + @LS_ROW_END + CHAR(9) + 'SET	ATTACHED_DOC.WRITE(@LO_ATTACHMENT2, @LN_@OFFSET2, @LN_DATA_LENGTH2)';
						SET @LS_SQL_CUR = @LS_SQL_CUR + @LS_ROW_END + CHAR(9) + 'WHERE	(PKEY = ' + CHAR(39) + @LS_PKEY + CHAR(39) + ');' + @LS_ROW_END;

						-- SUMA LA LONGITUD EN BYTES DEL SEGMENTO BLOB YA GRABADO AL VALOR DE OFFSET.
						SET @LS_SQL_CUR = @LS_SQL_CUR + @LS_ROW_END + CHAR(9) + 'SET @LN_@OFFSET2 = @LN_@OFFSET2 + @LN_DATA_LENGTH2;' + @LS_ROW_END;

						-- PROCESA LA SIGUIENTE FILA.
						SET @LS_SQL_CUR = @LS_SQL_CUR + @LS_ROW_END + CHAR(9) + 'FETCH NEXT FROM LO_CUR1 INTO' + SPACE(1);
						-- ASIGNACIÓN EN CONTADOR AUXILIAR.
						SET @LN_COUNT = 1;
						-- ITERACIÓN PARA ARMAR SQL DINÁMICO.
						WHILE (@LN_COUNT <= @LN_COL_COUNT) BEGIN
							-- ADICIONA VARIABLES AL FETCH DEL CURSOR.
							IF (@LN_COUNT < @LN_COL_COUNT) BEGIN
								SET @LS_SQL_CUR = @LS_SQL_CUR + '@LS_COL' + CONVERT(VARCHAR, @LN_COUNT) + ', ';
							END
							ELSE BEGIN
								SET @LS_SQL_CUR = @LS_SQL_CUR + '@LS_COL' + CONVERT(VARCHAR, @LN_COUNT) + ';' + @LS_ROW_END;
							END;
							-- INCREMENTA EL CONTADOR DE COLUMNAS.
							SET @LN_COUNT = @LN_COUNT + 1;
						END;

						-- FIN DEL CICLO WHILE Y CIERRE DEL CURSOR.
						SET @LS_SQL_CUR = @LS_SQL_CUR + 'END;' + @LS_ROW_END + @LS_ROW_END + 'CLOSE LO_CUR1;' + @LS_ROW_END + 'DEALLOCATE LO_CUR1;' + @LS_ROW_END;

						-- EJECUTA EL SQL DINÁMICO DE CARGA DEL CURSOR Y CICLO DE UPDATE DE LA TABLA.
						-- PRINT (@LS_SQL_CUR);
						EXECUTE (@LS_SQL_CUR);
						SELECT @LSOPERA = 'DECLARE', @LSTABLA = 'LO_CUR1', @LNFILAS_AFEC = @@ROWCOUNT, @LNERRORNUM = @@ERROR;
						IF (@LNERRORNUM <> 0) GOTO FALLO;

						-- RECUPERA EL ÚLTIMO VALOR DE @LN_@OFFSET.
						SELECT	@LN_@OFFSET = DATALENGTH(ATTACHED_DOC)
						FROM	PHYSICAL_ATTACHED_DOCUMENT_TMP
						WHERE	(PKEY = @LS_PKEY);

						-- SI EL ARCHIVO ES DE FORMATO XML, LLEVA FOOTER ADEMÁS DE RECIBIR LA ACTUALIZACIÓN DE PHYSICAL_ATTACHED_DOCUMENT.IMAGE_LEN.
						IF (@LS_FILE_FORMAT = 'XML') BEGIN
							-- ASIGNA EL REGISTRO DE FIN DE ARCHIVO A LA VARIABLE DE TIPO BLOB.
							SET @LO_ATTACHMENT = CONVERT(VARBINARY(MAX), @LS_FILE_FOOTER);
							-- INICIALIZA LAS VARIABLES QUE REQUIERE LA FUNCIÓN WRITE DE LA COLUMNA BLOB. CANTIDAD DE BYTES DEL BLOB Y VALOR DE OFFSET.
							SET @LN_DATA_LENGTH = DATALENGTH(@LO_ATTACHMENT);

							-- ACTUALIZA PHYSICAL_ATTACHED_DOCUMENT.ATTACHED_DOC CON EL REGISTRO DE FIN DE ARCHIVO Y PHYSICAL_ATTACHED_DOCUMENT.IMAGE_LEN CON LA LONGITUD EN BYTES DEL BLOB.
							UPDATE	TOP (1) PHYSICAL_ATTACHED_DOCUMENT_TMP
							SET	ATTACHED_DOC.WRITE(@LO_ATTACHMENT, @LN_@OFFSET, @LN_DATA_LENGTH),
								IMAGE_LEN = RIGHT(REPLICATE('0', 10) + CONVERT(VARCHAR(10), @LN_@OFFSET + @LN_DATA_LENGTH), 10)
							WHERE	(PKEY = @LS_PKEY);
						END
						ELSE BEGIN
							-- ACTUALIZA PHYSICAL_ATTACHED_DOCUMENT.IMAGE_LEN CON LA LONGITUD EN BYTES DEL BLOB.
							UPDATE	TOP (1) PHYSICAL_ATTACHED_DOCUMENT_TMP
							SET	IMAGE_LEN = RIGHT(REPLICATE('0', 10) + CONVERT(VARCHAR(10), @LN_@OFFSET + @LN_DATA_LENGTH), 10)
							WHERE	(PKEY = @LS_PKEY);
						END;
					END
					ELSE BEGIN
						DELETE FROM PHYSICAL_ATTACHED_DOCUMENT_TMP WHERE (PKEY = @LS_PKEY);
						SET @LS_RET_MESSAGE = 'NO SE HA INFORMADO EL PARÁMETRO OBLIGATORIO @PS_ROW_HEADER CUANDO SE ESPECIFICA EL PARÁMETRO @PS_QUERY.';
					END;
				END
				ELSE BEGIN
					DELETE FROM PHYSICAL_ATTACHED_DOCUMENT_TMP WHERE (PKEY = @LS_PKEY);
					SET @LS_RET_MESSAGE = 'NO SE HA POBLADO ALGUNO DE LOS PARÁMETROS OBLIGATORIOS Y MUTUAMENTE EXCLUYENTES @PO_ATTACHMENT Y @PS_QUERY.';
				END;
			END; -- SI SE MANDO UN ARCHIVO POR PARÁMETRO, YA FUE INSERTADO.
		END
		ELSE BEGIN
			SET @LS_RET_MESSAGE = 'YA EXISTE ARCHIVO ADJUNTO DE NOMBRE ' + @LS_FILE_NAME + ' PARA EL PROCESO CON LA CLAVE ' + @LS_PAR_KEY + '.';
		END;
	END
	ELSE BEGIN
		SET @LS_RET_MESSAGE = 'NO EXISTE EL PROCESO INFORMADO CON LA CLAVE ' + @LS_PAR_KEY + '.';
	END;
END
ELSE BEGIN
	SET @LS_RET_MESSAGE = 'NO SE HA POBLADO ALGUNO DE LOS PARÁMETROS OBLIGATORIOS @PS_PAR_KEY, @PS_DESCRIP, @PS_FILE_NAME Y @PS_USER_ID.';
END;

INSERT INTO	PHYSICAL_ATTACHED_DOCUMENT (PKEY, PAR_KEY, ATTACHED_DOC, ATTACHED_MESSAGE, FILE_NAME, TS_BEGIN, TS_END, TS_USER_ID, IMAGE_LEN, TS_CREATED_USER_ID)
			SELECT * FROM PHYSICAL_ATTACHED_DOCUMENT_TMP WHERE PKEY = @LS_PKEY	

-- DEVUELVE EL MENSAJE DE ERROR. NULL SI NO HUBO.
SET @PS_RET_MESSAGE = @LS_RET_MESSAGE;

FALLO:
-- REGISTRO DE SUCESOS Y CONTROL DE FIN DE PROCEDIMIENTO. CONCLUYE LA TRANSACCIÓN SI TODO FUE EXITOSO.
SELECT @LNDURACION = DATEDIFF(SECOND, @LDINICIO_OPE, GETDATE()), @LNSEVERITY = ISNULL(EM.SEVERITY, 16), @LSERRORDESC = 'ERROR ' + CONVERT(VARCHAR, ISNULL(EM.ERROR, 0)) + ' - ' + ISNULL(EM.DESCRIPTION, ' ') FROM MASTER.DBO.SYSMESSAGES EM WHERE (EM.ERROR = @LNERRORNUM);
IF (@LNERRORNUM <> 0) BEGIN
	-- NOTIFICACIÓN EN EL REGISTRO DE SQL SERVER.
	SET @LSERRORLOG = @LSERRORLOG + CASE WHEN (ISNULL(CHARINDEX('%', @LSERRORDESC), 0) > 0) THEN RTRIM(LEFT(@LSERRORDESC, 11)) ELSE @LSERRORDESC END;
	-- DEVUELVE EL ERROR EN EL PARÁMETRO DE SALIDA.
	SET @PS_RET_MESSAGE = SUBSTRING(@LSERRORDESC, 1, 440);
	-- DESHACE LA TRANSACCIÓN COMPLETA SI LA OPERACIÓN FALLÓ.
	IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION;
	EXECUTE @LNERRORNUM = PA_SYS_REGISTRO_SUCESOS_INSERT @PSPROCEDIMIENTO_1 = @LSPROC, @PSTABLA_2 = @LSTABLA, @PNFILAS_AFECTADAS_3 = @LNFILAS_AFEC, @PSOPERACION_4 = @LSOPERA, @PNDURACION_5 = @LNDURACION, @PSRESULTADO_6 = @LSERRORDESC, @PSSQL_CMD_7 = @LSERRORDESC;
END
ELSE BEGIN
	EXECUTE @LNERRORNUM = PA_SYS_REGISTRO_SUCESOS_INSERT @PSPROCEDIMIENTO_1 = @LSPROC, @PSTABLA_2 = @LSTABLA, @PNFILAS_AFECTADAS_3 = @LNFILAS_AFEC, @PSOPERACION_4 = @LSOPERA, @PNDURACION_5 = @LNDURACION, @PSRESULTADO_6 = @LSERRORDESC, @PSSQL_CMD_7 = @LSERRORDESC;
	IF (@@TRANCOUNT > 0) COMMIT TRANSACTION;
END;
RETURN;

